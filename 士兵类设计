我们首先需要设计一个基类作为接口，然后其他的只需要继承基类接口就可以了：
1.构造基类函数中的问题（虚函数）

构造函数为什么不能是虚函数呢？

    首先需要了解 vptr指针和虚函数表的概念，以及这两者的关联。

    vptr指针指向虚函数表，执行虚函数的时候，会调用vptr指针指向的虚函数的地址。

    当定义一个对象的时候，首先会分配对象内存空间，然后调用构造函数来初始化对象。vptr变量是在构造函数中进行初始化的。又因为执行虚函数需要通过vptr指针来调用。如果可以定义构造函数为虚函数，那么就会陷入先有鸡还是先有蛋的循环讨论中。

 

基类的析构函数为什么必须是虚函数呢？

    我们都知道，想要回收一个对象申请的资源，那么就需要调用析构函数。虽然我们没有显示地调用析构函数，但是编译器都会默认地为我们执行析构函数。

    那么当我们执行 BaseClass *base = new BaseClass(); 当我们执行 delete base时，会调用析构函数为我们释放资源。而 我们执行BaseClass *sub = new SubClass(); 如果BaseClass基类的析构函数不是虚函数的时候，delete sub 对象的时候，只会释放BaseClass 基类申请的资源，而不是释放SubClass派生类的资源。原因如下：

    基类指针指向了派生类对象，而基类中的析构函数是非virtual的，而虚构函数是动态绑定的基础。现在析构函数不是virtual的，因此不会发生动态绑定，而是静态绑定，指针的静态类型为基类指针，因此在delete的时候只会调用基类的析构函数，而不会调用派生类的析构函数。这样，在派生类中申请的资源就不会得到释放，就会造成内存泄漏，这是相当危险的：如果系统中有大量的派生类对象被这样创建和销毁，就会有内存不断的泄漏，久而久之，系统就会因为缺少内存而崩溃。

    当然，如果在派生类中没有动态申请有资源的时候，是不会造成内存泄漏的。而当派生类对象的析构函数中有内存需要回收，并且在编程过程中采用了基类指针指向派生类对象，如为了实现多态，并且通过基类指针将对象销毁，这时，就会因为基类的析构函数为非虚函数而不触发动态绑定，从而没有调用派生类的析构函数而导致内存泄漏。

    因此，为了防止这种情况下的内存泄漏的发生，最后将基类的析构函数写成virtual虚析构函数。

2.写一个城堡类，该城堡类中主要是能够统计和生成士兵
 'class' type redefinition
 多文件时，要注意不要重复读入

派生类定义拷贝构造时，需要先调用父辈的构造函数，否则会报错的
应该，应像如下调用：
derived(const derived& rhs) : base(rhs), y(rhs.y) {  }
先调用父类拷贝构造函数，给子类对象的父类组件(即x)赋值，然后再给子类对象的自身组件(即y)赋值
